% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../../tesi.tex
\subsection{JMeter - Modalità Distribuita}
Prima di descrivere la progettazione di JMeterOrchestrator, vorrei inizare questa sezione con una panoramica del funzionamento di JMeter in modalità distribuita (cluster mode), in modo da chiarire quali azioni fossero direttamente gestite da JMeter e specificare quali procedure invece sarebbero state prese in carico dall'orchestratore. \\
JMeter quando viene eseguito in cluster mode si divide in due entità:
\begin{itemize}
	\item \textbf{Master}: la macchina, fisica o virtuale, responsabile di coordinare le macchine slave e collezionare i dati da queste prodotti.
	\item \textbf{Slaves}: le macchine, fisiche o virtuali, responsabili di generare le richieste al server di destinazione, chiamato target.
\end{itemize}
L'esecuzione di JMeter in modalità distribuita avviene con l'immissione, tramite \gls{cli} sulla macchina master, di un comando simile:\\\\
\texttt{jmeter -n -t file.jmx -R 127.0.0.1 -l risultati.csv -e -o report}\\\\
Dove i parametri possiedono il seguente significato:
\begin{itemize}
	\item \textbf{-n}: non aprire la \gls{gui}, in modo da risparmiare RAM;
	\item \textbf{-t}: indica il file da utilizzare come test;
	\item \textbf{-R}: specifica gli indirizzi ip degli slaves da usare per l'esecuzione del test;
	\item \textbf{-l}: indica dove salvare i risultati;
	\item \textbf{-e -o}: indica dove generare il report HTML.
\end{itemize}
Il master assume quindi che gli slaves esistano e il server RMI, responsabile di ricevere le indicazione dal master, sia attivo e in stato di ricezione. Il master si assume poi la responsabilità di distribuire il file di test agli slaves, ma, eventuali file di dati (utili per specificare le credenziali degli utenti da simulare o altre configurazioni) devono essere caricati sulle macchine slaves a mano.\\
I file di test, suffissi \textit{jmx}, non solo racchiudono le richieste da effettuare sulla macchina target ma specificano anche la configurazione del carico da applicare, richiedendo una modifica del file di test in caso si voglia aggiustare qualche parametro della Load Generation. \\
In ultimo i file generati da JMeter vengono semplicemente scritti su disco ma non consumanti in qualsivoglia modo, questa caratteristica non è adatta per la realizzazione dei disposable servers, questi infatti vengono eliminati alla fine dei test, cancellando a loro volta i dati prodotti. \\
In sostanza quindi JMeter gestisce solo il coordinamento delle macchine slave, mentre sarà compito dell'orchestratore:
\begin{itemize}
	\item Assicurarsi che le macchine slave esistano (creandole eventualmente) e che abbiano il server RMI attivo;
	\item Distribuire eventuali file di dati alle macchine slaves;
	\item Prevedere una modalità di modifica della configurazione di carico senza richiedere la riscrittura del file \textit{jmx};
	\item Notificare l'avvenuto termine dei test, consegnando i file di risultati prodotti al team Legalmail via E-Mail.
\end{itemize}
\subsection{Principi}
Per la progettazione e successiva implementazione dell'orchestratore sono stati seguiti dei principi, o best practises, per garantire una solida codebase e una non troppo onerosa manutenzione.
\subsubsection{SOLID}
L'acrostico SOLID, descritto da Robert C. "Uncle Bob" Martin\footcite{book:designprinciples} all'inizio degli anni 2000, si riferisce a cinque principi fondamentali dello sviluppo software orientato agli oggetti e sono:
\begin{enumerate}
	\item \textbf{Single Responsability Principle (SRP)}: afferma che ogni classe dovrebbe avere una ed una sola responsabilità, interamente incapsulata al suo interno. Questa caratteristica troverà riscontro tramite la realizzazione dei \textbf{components}, come verrà specificato nella sezione successiva;
	\item \textbf{Open/Closed Principle (OCP)}: afferma che un'entità software dovrebbe essere aperta alle estensioni, ma chiusa alle modifiche. Su questo principio è stata riposta molta attenzione in quanto, come spiegato nella sezione precedente, le possibili evoluzioni del prodotto sarebbero dovute risultare poco onerose da implementare;
	\item \textbf{Liskov Substitution Principle (LSP)}: afferma che gli oggetti dovrebbero poter essere sostituiti con dei loro sottotipi, senza alterare il comportamento del programma che li utilizza. Questa caratteristica è implementata di default in python, in quanto linguaggio aderente al \gls{duck-typing};
	\item \textbf{Interface Segregation Principle (ISP)}: afferma che sarebbero preferibili più interfacce specifiche, che una singola generica. Questa principio viene rispettato con la definizione di più interfacce \textbf{actions} seppur strutturalmente simili, come verrà spiegato nelle sezioni successive;
	\item \textbf{Depedency Inversion Principle (DIP)}: afferma che una classe dovrebbe dipendere dalle astrazioni, non da classi concrete. Come indicato nella struttura del \textbf{Core} dell'orchestratore.
\end{enumerate} 
\subsubsection{KISS}
KISS, acronimo per \textit{Keep It Simple, Stupid}\footcite{article:drykiss}, è un principio che impone di mantenere il codice più semplice possibile. Lo scopo ultimo del codice è infatti quello di essere letto da altri umani: le aziende spendono di più per la manutenzione piuttosto che per sviluppo del software\footcite{article:maintenancesurvey}, quindi gli sviluppatori passano la maggior parte del tempo a sistemare il codice di altri piuttosto che crearne di nuovo.\\
Durante lo sviluppo dell'orchestratore quindi è stata posta molta attenzione sul \gls{refactor}, cercando di semplificare al minimo la logica di ogni parte del programma.
\subsubsection{DRY}
DRY, acronimo di \textit{Don't Repeat Yourself}\footcite{article:drykiss}, è un principio che impone di incapsulare le unità logiche applicative in modo da favorirne il riuso, evitando la ripetizione della stesura di linee di codice. \\
Ripetere in più parti della codebase la stessa funzionalità logica rende onerosa e complicata la manutenzione: la modifica di un concetto logico richiede la riscrittura di più parti dell'applicativo, rendendo difficile tracciare le modifiche effettuate.\\
Anche per questo principio è stata quindi posta molta attenzione sul \gls{refactor} in modo da evitare di incappare nell'antipattern WET, \textit{Wasting Everyone's Time}, esatto contrario del principio DRY.
\subsubsection{Immediately Repair Your Broken Windows}
Per ultimo, ma non meno importante, troviamo il \textit{Immediately Repair Your Broken Windows}\footcite{article:brokenwindow}, principio che unisce teorie dell'ambito della criminologia all'ingegneria del software. In sostanza questa teoria impone che bug, refusi di cattiva progettazione, violazione di principi di programmazione e problemi di questo tipo vadano corretti nell'immediato momento in cui vengono scoperti, in modo da ridurre al minimo il \gls{debito-tecnico}. \\
L'adozione di questo principio, oltre ad essere buona pratica in ogni situazione, assume maggiore rilevanza per il progetto di stage: essendo il tempo a disposizione molto limitato, consegnare un prodotto con bug conosciuti e magari non documentati avrebbe incattivito l'opinione sul software sviluppato, diminuendo le possibilità di adozione da parte dell'azienda e mettendo in cattiva luce la mia reputazione professionale. \\
L'obiettivo del progetto era quindi quello di avere codice, si strutturato e funzionale, ma soprattutto funzionante.

\subsection{Core}
Core Dependency Injection ->Principi OCP, DIP \\
Actions Interfaces --> Principio ISP \\
Components --> Principii DRY, SRP \\
\subsection{Actions}
\subsection{Command Line Interface}
\subsection{Enterprise Edition}